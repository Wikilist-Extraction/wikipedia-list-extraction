package ratings

import akka.stream.Materializer
import akka.stream.scaladsl.Source
import chalk.text.analyze.PorterStemmer
import chalk.text.tokenize.SimpleEnglishTokenizer
import dataFormats.{WikiLink, WikiListResult}
import sparql.JenaTitleAbstractDumpWrapper

import scala.async.Async.{async, await}
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.Future
import scala.reflect.io.Directory

object TextEvidenceRating extends Rating {
  val name = 'textEvidence

  val titleWeight : Double = 0.2
  val abstractWeight : Double = 0.2
  val parentTitleWeight : Double = 0.4
  val categoryWeight: Double = 0.2


  val tokenizer = SimpleEnglishTokenizer.V0()

  val camelCaseRegex = "([a-z](?=[A-Z]))".r

  val abstractQueryString =
    """
      select ?abstract where
      { ?uri rdfs:comment ?abstract. FILTER (langMatches(lang(?abstract),'en')) }
    """

  val titleQueryString =
    """
      select ?title where
      { ?uri rdfs:label ?title. FILTER (langMatches(lang(?title),'en')) }
    """
}

class TextEvidenceRating extends JenaTitleAbstractDumpWrapper with RatingResult {
  import ratings.TextEvidenceRating._

  val titleTdbDirectory: String = "db/titles"
  val abstractTdbDirectory: String = "db/abstracts"

  assert(!Directory(titleTdbDirectory).isEmpty)
  assert(!Directory(abstractTdbDirectory).isEmpty)

  def getAbstract(uri: String) : Future[List[String]] = {
    val abstractText = queryAbstractDumpWithUri(abstractQueryString, uri)
      .map ( _.map (_.getLiteral("abstract").getString))
      .map ( _.headOption.getOrElse("") )
      .map (text => tokenizeAndStem(text))

    abstractText
  }

  def getTitle(uri: String) : Future[List[String]] = {
    val titleText = queryTitleDumpWithUri(titleQueryString, uri)
      .map(_.map(_.getLiteral("title").getString))
      .map(_.headOption.getOrElse(""))
      .map(text => tokenizeAndStem(text))

    titleText
  }

  def getAbstractsAndTitle(uri: String): Future[(List[String], List[String])] = {
    async {
      val titleText = await(getTitle(uri))
      val abstractText = await(getAbstract(uri))

      (titleText, abstractText)
    }
  }

  def cleanType(typeUri: String) : String = {
    /* "http://dbpedia.org/class/yago/LivingThing100004258" -> "living thing" */
    var typeLabel = typeUri.substring(typeUri.lastIndexOf('/') + 1)
    typeLabel = "\\d".r.replaceAllIn(typeLabel, "")
    camelCaseRegex.replaceAllIn(typeLabel, "$1 ").toLowerCase
  }

  def normalizeTypes(types: List[String]): List[(String, List[String])] = {
    types map { typeLabel: String =>
      val cleanedLabel = cleanType(typeLabel)

      typeLabel -> tokenizeAndStem(cleanedLabel)
    }
  }

  def cleanCategory(categoryID: String) : String = {
    /* "Category:1956_in_the_United_States" -> "1956 in the united states" */
    categoryID.substring(categoryID.lastIndexOf("Category:") + 9).replace("_", " ")
  }

  def normalizeCategories(categories: List[WikiLink]): List[List[String]] = {
    categories map { category =>
      val cleanedLabel = cleanCategory(category.id)

      tokenizeAndStem(cleanedLabel)
    }
  }

  def tokenizeAndStem(text: String) : List[String] = {
    val tokenized = tokenizer(text.toLowerCase)
    tokenized.map(token => PorterStemmer(token)).toList
  }

  def countType(typeLabels: List[String], text: List[String]) : Double = {
    val counts = typeLabels map { typeLabel: String =>
      var count = 0
      for (token <- text) {
        if (typeLabel == token) { count += 1 }
      }

      count
    }

    counts.min
  }

  def rateTypes(types: List[(String, List[String])], abstractsMapFuture: Future[List[(List[String], List[String])]], parentTitle: List[String], categories: List[List[String]]) : Future[List[(String, Double)]] = {
    val typeCounts = types map { typeTupel =>
      val typeLabel = typeTupel._1
      val normalizedType = typeTupel._2

      var titleCount: Double = 0
      var abstractCount: Double = 0
      var parentTitleCount: Double = 0
      var categoryCount: Double = 0

      abstractsMapFuture.map(abstractsMap => {
        /* Count type in parent title */
        parentTitleCount += countType(normalizedType, parentTitle)

        /* Count type in categories */
        for (categoryText <- categories) {
          categoryCount += countType(normalizedType, categoryText)
        }

        /* count type in titles and abstracts */
        for (abstractTupel <- abstractsMap) {
          val abstractTitle = abstractTupel._1
          val abstractText = abstractTupel._2

          titleCount += countType(normalizedType, abstractTitle)
          abstractCount += countType(normalizedType, abstractText)
        }

        typeLabel -> (titleCount * titleWeight + abstractCount * abstractWeight +
          parentTitleCount * parentTitleWeight + categoryCount * categoryWeight)
      })
    }

    Future.sequence(typeCounts)
  }

  /* Expects a list of uris for each list entity and a list of all types (generated by tf-idf) */
  def compute(title: String, uris: List[String], types: Map[String, Int], categories: List[WikiLink])(implicit materializer: Materializer): Future[Map[String, Double]] = {

    val normalizedTypes = normalizeTypes(types.keys.toList)
    val parentTitle = tokenizeAndStem(title.toLowerCase)
    val categoryLabels = normalizeCategories(categories)

    val abstractsMap = Source(uris)
      .mapAsyncUnordered(10)(getAbstractsAndTitle)
      .runFold[List[(List[String], List[String])]](List())((acc, elem) => elem :: acc)

    rateTypes(normalizedTypes, abstractsMap, parentTitle, categoryLabels)
      .map(_.toMap)
  }

  def getRating(result: WikiListResult)(implicit materializer: Materializer): Future[Map[String, Double]] = {
    compute(result.page.title, result.page.getEntityUris, result.types, result.page.categories)
  }
}
